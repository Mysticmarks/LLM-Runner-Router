<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: enterprise/EnterpriseAuth.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: enterprise/EnterpriseAuth.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * ðŸ” Enterprise Authentication
 * Comprehensive authentication and authorization system
 * Echo AI Systems - Enterprise-grade security and identity management
 */

import { EventEmitter } from 'events';
import { Logger } from '../utils/Logger.js';
import crypto from 'crypto';
import jwt from 'jsonwebtoken';

const logger = new Logger('EnterpriseAuth');

/**
 * Authentication methods
 */
export const AuthMethods = {
  LOCAL: 'local',
  SAML: 'saml',
  OAUTH: 'oauth',
  OIDC: 'oidc',
  LDAP: 'ldap',
  ACTIVE_DIRECTORY: 'active_directory',
  API_KEY: 'api_key',
  CERTIFICATE: 'certificate'
};

/**
 * User roles
 */
export const UserRoles = {
  SUPER_ADMIN: 'super_admin',
  ADMIN: 'admin',
  OPERATOR: 'operator',
  DEVELOPER: 'developer',
  USER: 'user',
  VIEWER: 'viewer',
  GUEST: 'guest'
};

/**
 * Permissions
 */
export const Permissions = {
  // System administration
  SYSTEM_ADMIN: 'system:admin',
  SYSTEM_CONFIG: 'system:config',
  SYSTEM_MONITOR: 'system:monitor',
  
  // User management
  USER_CREATE: 'user:create',
  USER_UPDATE: 'user:update',
  USER_DELETE: 'user:delete',
  USER_VIEW: 'user:view',
  
  // Model operations
  MODEL_LOAD: 'model:load',
  MODEL_UNLOAD: 'model:unload',
  MODEL_INFERENCE: 'model:inference',
  MODEL_CONFIGURE: 'model:configure',
  
  // Data operations
  DATA_READ: 'data:read',
  DATA_WRITE: 'data:write',
  DATA_DELETE: 'data:delete',
  DATA_EXPORT: 'data:export',
  
  // API access
  API_READ: 'api:read',
  API_WRITE: 'api:write',
  API_ADMIN: 'api:admin',
  
  // Tenant operations
  TENANT_CREATE: 'tenant:create',
  TENANT_UPDATE: 'tenant:update',
  TENANT_DELETE: 'tenant:delete',
  TENANT_VIEW: 'tenant:view'
};

/**
 * Session types
 */
export const SessionTypes = {
  INTERACTIVE: 'interactive',
  API: 'api',
  SERVICE: 'service',
  TEMPORARY: 'temporary'
};

/**
 * Enterprise Authentication Manager
 */
class EnterpriseAuthManager extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      // JWT configuration
      jwtSecret: config.jwtSecret || this.generateSecret(),
      jwtExpiration: config.jwtExpiration || '24h',
      
      // Session configuration
      sessionTimeout: config.sessionTimeout || 30 * 60 * 1000, // 30 minutes
      maxSessions: config.maxSessions || 5,
      
      // Password policies
      passwordPolicy: {
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        maxAge: 90 * 24 * 60 * 60 * 1000, // 90 days
        ...config.passwordPolicy
      },
      
      // MFA configuration
      mfaRequired: config.mfaRequired || false,
      mfaMethods: config.mfaMethods || ['totp', 'sms'],
      
      // SAML configuration
      saml: config.saml || {},
      
      // OAuth/OIDC configuration
      oauth: config.oauth || {},
      
      // LDAP configuration
      ldap: config.ldap || {},
      
      // Rate limiting
      rateLimiting: {
        loginAttempts: 5,
        lockoutDuration: 15 * 60 * 1000, // 15 minutes
        ...config.rateLimiting
      },
      
      ...config
    };
    
    // User storage
    this.users = new Map();
    this.sessions = new Map();
    this.apiKeys = new Map();
    
    // Role and permission system
    this.roles = new Map();
    this.permissions = new Map();
    
    // Authentication providers
    this.authProviders = new Map();
    
    // Security tracking
    this.loginAttempts = new Map(); // userId -> attempt data
    this.blockedUsers = new Map();
    
    // Session management
    this.activeSessions = new Map(); // userId -> session IDs
    
    this.initializeDefaultRoles();
    this.initializeAuthProviders();
    
    logger.info('ðŸ” Enterprise authentication initialized', {
      methods: Object.keys(this.authProviders),
      mfa: this.config.mfaRequired
    });
  }

  /**
   * Register user
   * @param {object} userData - User data
   */
  async registerUser(userData) {
    const user = {
      id: userData.id || this.generateUserId(),
      username: userData.username,
      email: userData.email,
      displayName: userData.displayName || userData.username,
      
      // Authentication data
      passwordHash: userData.password ? await this.hashPassword(userData.password) : null,
      authMethod: userData.authMethod || AuthMethods.LOCAL,
      
      // Profile data
      profile: userData.profile || {},
      
      // Security settings
      roles: userData.roles || [UserRoles.USER],
      permissions: userData.permissions || [],
      mfaEnabled: userData.mfaEnabled || false,
      mfaSecret: userData.mfaEnabled ? this.generateMFASecret() : null,
      
      // Status
      status: 'active',
      emailVerified: userData.emailVerified || false,
      
      // Timestamps
      createdAt: new Date(),
      updatedAt: new Date(),
      lastLoginAt: null,
      passwordChangedAt: new Date(),
      
      // External provider data
      externalIds: userData.externalIds || {},
      
      ...userData
    };
    
    // Validate user data
    this.validateUserData(user);
    
    // Check for duplicates
    if (this.findUserByUsername(user.username)) {
      throw new Error(`Username already exists: ${user.username}`);
    }
    
    if (this.findUserByEmail(user.email)) {
      throw new Error(`Email already exists: ${user.email}`);
    }
    
    // Store user
    this.users.set(user.id, user);
    
    this.emit('user-registered', user);
    logger.info(`ðŸ‘¤ User registered: ${user.username} (${user.id})`);
    
    return { ...user, passwordHash: undefined, mfaSecret: undefined };
  }

  /**
   * Authenticate user
   * @param {string} identifier - Username or email
   * @param {string} password - Password
   * @param {object} options - Authentication options
   */
  async authenticate(identifier, password, options = {}) {
    const startTime = Date.now();
    
    try {
      // Find user
      const user = this.findUserByIdentifier(identifier);
      if (!user) {
        await this.recordFailedAttempt(identifier, 'user_not_found');
        throw new Error('Invalid credentials');
      }
      
      // Check if user is blocked
      if (this.isUserBlocked(user.id)) {
        throw new Error('Account temporarily locked');
      }
      
      // Check account status
      if (user.status !== 'active') {
        throw new Error(`Account ${user.status}`);
      }
      
      // Verify password
      const passwordValid = await this.verifyPassword(password, user.passwordHash);
      if (!passwordValid) {
        await this.recordFailedAttempt(user.id, 'invalid_password');
        throw new Error('Invalid credentials');
      }
      
      // Check MFA if required
      if (user.mfaEnabled &amp;&amp; !options.skipMFA) {
        if (!options.mfaToken) {
          return {
            requiresMFA: true,
            mfaMethods: this.config.mfaMethods,
            tempToken: this.generateTempToken(user.id)
          };
        }
        
        const mfaValid = await this.verifyMFA(user, options.mfaToken);
        if (!mfaValid) {
          await this.recordFailedAttempt(user.id, 'invalid_mfa');
          throw new Error('Invalid MFA token');
        }
      }
      
      // Clear failed attempts
      this.clearFailedAttempts(user.id);
      
      // Create session
      const session = await this.createSession(user, options);
      
      // Update user login time
      user.lastLoginAt = new Date();
      user.updatedAt = new Date();
      
      const authResult = {
        user: { ...user, passwordHash: undefined, mfaSecret: undefined },
        session,
        token: session.token,
        expiresAt: session.expiresAt
      };
      
      this.emit('user-authenticated', {
        userId: user.id,
        username: user.username,
        authMethod: user.authMethod,
        duration: Date.now() - startTime
      });
      
      logger.info(`âœ… User authenticated: ${user.username}`);
      
      return authResult;
      
    } catch (error) {
      this.emit('authentication-failed', {
        identifier,
        error: error.message,
        duration: Date.now() - startTime
      });
      
      logger.warn(`âŒ Authentication failed for ${identifier}: ${error.message}`);
      throw error;
    }
  }

  /**
   * Authenticate with external provider
   * @param {string} provider - Provider name
   * @param {object} providerData - Provider-specific data
   */
  async authenticateWithProvider(provider, providerData) {
    const authProvider = this.authProviders.get(provider);
    if (!authProvider) {
      throw new Error(`Unknown auth provider: ${provider}`);
    }
    
    try {
      // Validate with provider
      const externalUser = await authProvider.validate(providerData);
      
      // Find or create user
      let user = this.findUserByExternalId(provider, externalUser.id);
      
      if (!user) {
        // Auto-register user from external provider
        user = await this.registerUser({
          username: externalUser.username || externalUser.email,
          email: externalUser.email,
          displayName: externalUser.displayName,
          authMethod: provider,
          externalIds: { [provider]: externalUser.id },
          profile: externalUser.profile || {},
          emailVerified: true // Trust external provider
        });
      } else {
        // Update user data from provider
        user.updatedAt = new Date();
        user.lastLoginAt = new Date();
        if (externalUser.profile) {
          user.profile = { ...user.profile, ...externalUser.profile };
        }
      }
      
      // Create session
      const session = await this.createSession(user, { provider });
      
      this.emit('external-authentication', {
        userId: user.id,
        provider,
        externalId: externalUser.id
      });
      
      return {
        user: { ...user, passwordHash: undefined, mfaSecret: undefined },
        session,
        token: session.token,
        expiresAt: session.expiresAt
      };
      
    } catch (error) {
      logger.error(`External auth failed for ${provider}:`, error);
      throw error;
    }
  }

  /**
   * Validate token
   * @param {string} token - JWT token
   */
  async validateToken(token) {
    try {
      const decoded = jwt.verify(token, this.config.jwtSecret);
      
      // Check if session exists
      const session = this.sessions.get(decoded.sessionId);
      if (!session) {
        throw new Error('Session not found');
      }
      
      // Check if session is expired
      if (session.expiresAt &lt; new Date()) {
        this.sessions.delete(session.id);
        throw new Error('Session expired');
      }
      
      // Get user
      const user = this.users.get(session.userId);
      if (!user || user.status !== 'active') {
        throw new Error('User not found or inactive');
      }
      
      // Update session activity
      session.lastActiveAt = new Date();
      
      return {
        user: { ...user, passwordHash: undefined, mfaSecret: undefined },
        session,
        permissions: await this.getUserPermissions(user)
      };
      
    } catch (error) {
      logger.debug(`Token validation failed: ${error.message}`);
      throw new Error('Invalid token');
    }
  }

  /**
   * Refresh token
   * @param {string} refreshToken - Refresh token
   */
  async refreshToken(refreshToken) {
    const session = Array.from(this.sessions.values())
      .find(s => s.refreshToken === refreshToken);
    
    if (!session) {
      throw new Error('Invalid refresh token');
    }
    
    if (session.refreshExpiresAt &lt; new Date()) {
      this.sessions.delete(session.id);
      throw new Error('Refresh token expired');
    }
    
    // Generate new tokens
    const newToken = this.generateJWT(session);
    const newRefreshToken = this.generateRefreshToken();
    
    session.token = newToken;
    session.refreshToken = newRefreshToken;
    session.expiresAt = new Date(Date.now() + this.parseTimeString(this.config.jwtExpiration));
    session.refreshExpiresAt = new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)); // 7 days
    
    return {
      token: newToken,
      refreshToken: newRefreshToken,
      expiresAt: session.expiresAt
    };
  }

  /**
   * Logout user
   * @param {string} sessionId - Session ID
   */
  async logout(sessionId) {
    const session = this.sessions.get(sessionId);
    if (!session) {
      return;
    }
    
    // Remove from active sessions
    const userSessions = this.activeSessions.get(session.userId) || new Set();
    userSessions.delete(sessionId);
    
    if (userSessions.size === 0) {
      this.activeSessions.delete(session.userId);
    } else {
      this.activeSessions.set(session.userId, userSessions);
    }
    
    // Delete session
    this.sessions.delete(sessionId);
    
    this.emit('user-logout', {
      userId: session.userId,
      sessionId
    });
    
    logger.info(`ðŸ‘‹ User logged out: ${session.userId}`);
  }

  /**
   * Create API key
   * @param {string} userId - User ID
   * @param {object} options - API key options
   */
  async createAPIKey(userId, options = {}) {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    const apiKey = {
      id: this.generateAPIKeyId(),
      key: this.generateAPIKey(),
      userId,
      name: options.name || 'API Key',
      permissions: options.permissions || [],
      
      // Restrictions
      ipWhitelist: options.ipWhitelist || [],
      rateLimit: options.rateLimit,
      
      // Status
      enabled: true,
      
      // Timestamps
      createdAt: new Date(),
      expiresAt: options.expiresAt,
      lastUsedAt: null,
      
      // Usage tracking
      usageCount: 0,
      
      ...options
    };
    
    this.apiKeys.set(apiKey.id, apiKey);
    
    this.emit('api-key-created', {
      userId,
      keyId: apiKey.id,
      name: apiKey.name
    });
    
    logger.info(`ðŸ”‘ API key created for user ${userId}: ${apiKey.name}`);
    
    return apiKey;
  }

  /**
   * Validate API key
   * @param {string} key - API key
   * @param {object} context - Request context
   */
  async validateAPIKey(key, context = {}) {
    const apiKey = Array.from(this.apiKeys.values())
      .find(k => k.key === key &amp;&amp; k.enabled);
    
    if (!apiKey) {
      throw new Error('Invalid API key');
    }
    
    // Check expiration
    if (apiKey.expiresAt &amp;&amp; apiKey.expiresAt &lt; new Date()) {
      throw new Error('API key expired');
    }
    
    // Check IP whitelist
    if (apiKey.ipWhitelist.length > 0 &amp;&amp; context.ip) {
      if (!apiKey.ipWhitelist.includes(context.ip)) {
        throw new Error('IP not whitelisted');
      }
    }
    
    // Check rate limit
    if (apiKey.rateLimit) {
      // Implementation would check rate limiting
    }
    
    // Update usage
    apiKey.lastUsedAt = new Date();
    apiKey.usageCount++;
    
    // Get user
    const user = this.users.get(apiKey.userId);
    if (!user || user.status !== 'active') {
      throw new Error('User not found or inactive');
    }
    
    return {
      user: { ...user, passwordHash: undefined, mfaSecret: undefined },
      apiKey: { ...apiKey, key: undefined },
      permissions: [...await this.getUserPermissions(user), ...apiKey.permissions]
    };
  }

  /**
   * Check permission
   * @param {object} context - Authorization context
   * @param {string} permission - Required permission
   */
  async checkPermission(context, permission) {
    const userPermissions = context.permissions || [];
    
    // Check direct permission
    if (userPermissions.includes(permission)) {
      return true;
    }
    
    // Check wildcard permissions
    const permissionParts = permission.split(':');
    for (let i = permissionParts.length; i > 0; i--) {
      const wildcardPermission = permissionParts.slice(0, i).join(':') + ':*';
      if (userPermissions.includes(wildcardPermission)) {
        return true;
      }
    }
    
    // Check super admin
    if (userPermissions.includes('*') || userPermissions.includes('admin:*')) {
      return true;
    }
    
    return false;
  }

  /**
   * Assign role to user
   * @param {string} userId - User ID
   * @param {string} role - Role name
   */
  async assignRole(userId, role) {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    if (!this.roles.has(role)) {
      throw new Error(`Role not found: ${role}`);
    }
    
    if (!user.roles.includes(role)) {
      user.roles.push(role);
      user.updatedAt = new Date();
      
      this.emit('role-assigned', { userId, role });
      logger.info(`ðŸ‘¤ Role assigned to ${user.username}: ${role}`);
    }
  }

  /**
   * Remove role from user
   * @param {string} userId - User ID
   * @param {string} role - Role name
   */
  async removeRole(userId, role) {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    const roleIndex = user.roles.indexOf(role);
    if (roleIndex > -1) {
      user.roles.splice(roleIndex, 1);
      user.updatedAt = new Date();
      
      this.emit('role-removed', { userId, role });
      logger.info(`ðŸ‘¤ Role removed from ${user.username}: ${role}`);
    }
  }

  /**
   * Get user permissions
   * @param {object} user - User object
   */
  async getUserPermissions(user) {
    const permissions = new Set(user.permissions || []);
    
    // Add role permissions
    for (const roleName of user.roles) {
      const role = this.roles.get(roleName);
      if (role) {
        for (const permission of role.permissions) {
          permissions.add(permission);
        }
      }
    }
    
    return Array.from(permissions);
  }

  /**
   * Enable MFA for user
   * @param {string} userId - User ID
   */
  async enableMFA(userId) {
    const user = this.users.get(userId);
    if (!user) {
      throw new Error('User not found');
    }
    
    if (user.mfaEnabled) {
      throw new Error('MFA already enabled');
    }
    
    const mfaSecret = this.generateMFASecret();
    user.mfaSecret = mfaSecret;
    user.mfaEnabled = true;
    user.updatedAt = new Date();
    
    this.emit('mfa-enabled', { userId });
    logger.info(`ðŸ” MFA enabled for user: ${user.username}`);
    
    return {
      secret: mfaSecret,
      qrCode: this.generateMFAQRCode(user.username, mfaSecret)
    };
  }

  // Private methods

  /**
   * Initialize default roles
   * @private
   */
  initializeDefaultRoles() {
    // Super Admin role
    this.roles.set(UserRoles.SUPER_ADMIN, {
      name: UserRoles.SUPER_ADMIN,
      description: 'Full system access',
      permissions: ['*']
    });
    
    // Admin role
    this.roles.set(UserRoles.ADMIN, {
      name: UserRoles.ADMIN,
      description: 'Administrative access',
      permissions: [
        Permissions.SYSTEM_CONFIG,
        Permissions.SYSTEM_MONITOR,
        Permissions.USER_CREATE,
        Permissions.USER_UPDATE,
        Permissions.USER_DELETE,
        Permissions.USER_VIEW,
        Permissions.MODEL_LOAD,
        Permissions.MODEL_UNLOAD,
        Permissions.MODEL_CONFIGURE,
        Permissions.API_ADMIN,
        Permissions.TENANT_CREATE,
        Permissions.TENANT_UPDATE,
        Permissions.TENANT_DELETE,
        Permissions.TENANT_VIEW
      ]
    });
    
    // Operator role
    this.roles.set(UserRoles.OPERATOR, {
      name: UserRoles.OPERATOR,
      description: 'Operational access',
      permissions: [
        Permissions.SYSTEM_MONITOR,
        Permissions.USER_VIEW,
        Permissions.MODEL_LOAD,
        Permissions.MODEL_UNLOAD,
        Permissions.MODEL_INFERENCE,
        Permissions.API_WRITE,
        Permissions.TENANT_VIEW
      ]
    });
    
    // Developer role
    this.roles.set(UserRoles.DEVELOPER, {
      name: UserRoles.DEVELOPER,
      description: 'Development access',
      permissions: [
        Permissions.MODEL_INFERENCE,
        Permissions.DATA_READ,
        Permissions.DATA_WRITE,
        Permissions.API_READ,
        Permissions.API_WRITE
      ]
    });
    
    // User role
    this.roles.set(UserRoles.USER, {
      name: UserRoles.USER,
      description: 'Standard user access',
      permissions: [
        Permissions.MODEL_INFERENCE,
        Permissions.DATA_READ,
        Permissions.API_READ
      ]
    });
    
    // Viewer role
    this.roles.set(UserRoles.VIEWER, {
      name: UserRoles.VIEWER,
      description: 'Read-only access',
      permissions: [
        Permissions.DATA_READ,
        Permissions.API_READ
      ]
    });
  }

  /**
   * Initialize authentication providers
   * @private
   */
  initializeAuthProviders() {
    // SAML provider
    if (this.config.saml.enabled) {
      this.authProviders.set(AuthMethods.SAML, {
        validate: async (data) => {
          // SAML validation logic
          return this.validateSAMLAssertion(data);
        }
      });
    }
    
    // OAuth provider
    if (this.config.oauth.enabled) {
      this.authProviders.set(AuthMethods.OAUTH, {
        validate: async (data) => {
          // OAuth validation logic
          return this.validateOAuthToken(data);
        }
      });
    }
    
    // OIDC provider
    if (this.config.oidc?.enabled) {
      this.authProviders.set(AuthMethods.OIDC, {
        validate: async (data) => {
          // OIDC validation logic
          return this.validateOIDCToken(data);
        }
      });
    }
    
    // LDAP provider
    if (this.config.ldap.enabled) {
      this.authProviders.set(AuthMethods.LDAP, {
        validate: async (data) => {
          // LDAP validation logic
          return this.validateLDAPCredentials(data);
        }
      });
    }
  }

  /**
   * Generate secret
   * @private
   */
  generateSecret() {
    return crypto.randomBytes(64).toString('hex');
  }

  /**
   * Generate user ID
   * @private
   */
  generateUserId() {
    return 'user_' + crypto.randomBytes(16).toString('hex');
  }

  /**
   * Generate API key ID
   * @private
   */
  generateAPIKeyId() {
    return 'key_' + crypto.randomBytes(16).toString('hex');
  }

  /**
   * Generate API key
   * @private
   */
  generateAPIKey() {
    return 'ak_' + crypto.randomBytes(32).toString('hex');
  }

  /**
   * Generate MFA secret
   * @private
   */
  generateMFASecret() {
    return crypto.randomBytes(20).toString('base32');
  }

  /**
   * Generate temp token
   * @private
   */
  generateTempToken(userId) {
    return jwt.sign(
      { userId, type: 'temp' },
      this.config.jwtSecret,
      { expiresIn: '10m' }
    );
  }

  /**
   * Hash password
   * @private
   */
  async hashPassword(password) {
    const salt = crypto.randomBytes(16).toString('hex');
    const hash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    return `${salt}:${hash}`;
  }

  /**
   * Verify password
   * @private
   */
  async verifyPassword(password, hash) {
    if (!hash) return false;
    
    const [salt, storedHash] = hash.split(':');
    const passwordHash = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex');
    return passwordHash === storedHash;
  }

  /**
   * Verify MFA token
   * @private
   */
  async verifyMFA(user, token) {
    // Simplified TOTP verification
    // In production, use proper TOTP library
    return token === '123456'; // Mock verification
  }

  /**
   * Validate user data
   * @private
   */
  validateUserData(user) {
    if (!user.username) {
      throw new Error('Username is required');
    }
    
    if (!user.email) {
      throw new Error('Email is required');
    }
    
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(user.email)) {
      throw new Error('Invalid email format');
    }
    
    if (user.password &amp;&amp; !this.isPasswordValid(user.password)) {
      throw new Error('Password does not meet policy requirements');
    }
  }

  /**
   * Check password policy
   * @private
   */
  isPasswordValid(password) {
    const policy = this.config.passwordPolicy;
    
    if (password.length &lt; policy.minLength) {
      return false;
    }
    
    if (policy.requireUppercase &amp;&amp; !/[A-Z]/.test(password)) {
      return false;
    }
    
    if (policy.requireLowercase &amp;&amp; !/[a-z]/.test(password)) {
      return false;
    }
    
    if (policy.requireNumbers &amp;&amp; !/\d/.test(password)) {
      return false;
    }
    
    if (policy.requireSpecialChars &amp;&amp; !/[!@#$%^&amp;*]/.test(password)) {
      return false;
    }
    
    return true;
  }

  /**
   * Find user by identifier
   * @private
   */
  findUserByIdentifier(identifier) {
    return this.findUserByUsername(identifier) || this.findUserByEmail(identifier);
  }

  /**
   * Find user by username
   * @private
   */
  findUserByUsername(username) {
    return Array.from(this.users.values())
      .find(user => user.username === username);
  }

  /**
   * Find user by email
   * @private
   */
  findUserByEmail(email) {
    return Array.from(this.users.values())
      .find(user => user.email === email);
  }

  /**
   * Find user by external ID
   * @private
   */
  findUserByExternalId(provider, externalId) {
    return Array.from(this.users.values())
      .find(user => user.externalIds &amp;&amp; user.externalIds[provider] === externalId);
  }

  /**
   * Create session
   * @private
   */
  async createSession(user, options = {}) {
    const sessionId = this.generateSessionId();
    const token = this.generateJWT({ userId: user.id, sessionId });
    const refreshToken = this.generateRefreshToken();
    
    const session = {
      id: sessionId,
      userId: user.id,
      token,
      refreshToken,
      type: options.type || SessionTypes.INTERACTIVE,
      
      // Timestamps
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + this.parseTimeString(this.config.jwtExpiration)),
      refreshExpiresAt: new Date(Date.now() + (7 * 24 * 60 * 60 * 1000)), // 7 days
      lastActiveAt: new Date(),
      
      // Context
      ipAddress: options.ipAddress,
      userAgent: options.userAgent,
      provider: options.provider,
      
      // Metadata
      metadata: options.metadata || {}
    };
    
    // Store session
    this.sessions.set(sessionId, session);
    
    // Track active sessions per user
    const userSessions = this.activeSessions.get(user.id) || new Set();
    userSessions.add(sessionId);
    
    // Enforce max sessions
    if (userSessions.size > this.config.maxSessions) {
      const oldestSessionId = Array.from(userSessions)[0];
      await this.logout(oldestSessionId);
      userSessions.delete(oldestSessionId);
    }
    
    this.activeSessions.set(user.id, userSessions);
    
    return session;
  }

  /**
   * Generate session ID
   * @private
   */
  generateSessionId() {
    return 'sess_' + crypto.randomBytes(24).toString('hex');
  }

  /**
   * Generate JWT
   * @private
   */
  generateJWT(payload) {
    return jwt.sign(payload, this.config.jwtSecret, {
      expiresIn: this.config.jwtExpiration
    });
  }

  /**
   * Generate refresh token
   * @private
   */
  generateRefreshToken() {
    return crypto.randomBytes(32).toString('hex');
  }

  /**
   * Parse time string to milliseconds
   * @private
   */
  parseTimeString(timeString) {
    const timeMap = {
      's': 1000,
      'm': 60 * 1000,
      'h': 60 * 60 * 1000,
      'd': 24 * 60 * 60 * 1000
    };
    
    const match = timeString.match(/^(\d+)([smhd])$/);
    if (!match) {
      return 24 * 60 * 60 * 1000; // Default to 24 hours
    }
    
    const [, amount, unit] = match;
    return parseInt(amount) * timeMap[unit];
  }

  /**
   * Record failed attempt
   * @private
   */
  async recordFailedAttempt(identifier, reason) {
    const attempts = this.loginAttempts.get(identifier) || {
      count: 0,
      firstAttempt: Date.now(),
      lastAttempt: Date.now(),
      reasons: []
    };
    
    attempts.count++;
    attempts.lastAttempt = Date.now();
    attempts.reasons.push(reason);
    
    this.loginAttempts.set(identifier, attempts);
    
    // Check if user should be blocked
    if (attempts.count >= this.config.rateLimiting.loginAttempts) {
      this.blockedUsers.set(identifier, {
        blockedAt: Date.now(),
        unblockAt: Date.now() + this.config.rateLimiting.lockoutDuration
      });
      
      logger.warn(`ðŸš« User blocked due to failed attempts: ${identifier}`);
    }
  }

  /**
   * Clear failed attempts
   * @private
   */
  clearFailedAttempts(identifier) {
    this.loginAttempts.delete(identifier);
    this.blockedUsers.delete(identifier);
  }

  /**
   * Check if user is blocked
   * @private
   */
  isUserBlocked(identifier) {
    const blockInfo = this.blockedUsers.get(identifier);
    if (!blockInfo) {
      return false;
    }
    
    if (Date.now() > blockInfo.unblockAt) {
      this.blockedUsers.delete(identifier);
      return false;
    }
    
    return true;
  }

  /**
   * Generate MFA QR code
   * @private
   */
  generateMFAQRCode(username, secret) {
    // In production, use proper QR code generation library
    return `otpauth://totp/LLMRouter:${username}?secret=${secret}&amp;issuer=LLMRouter`;
  }

  /**
   * Validate SAML assertion
   * @private
   */
  async validateSAMLAssertion(data) {
    // SAML validation implementation
    // This would integrate with SAML library
    throw new Error('SAML validation not implemented');
  }

  /**
   * Validate OAuth token
   * @private
   */
  async validateOAuthToken(data) {
    // OAuth validation implementation
    // This would integrate with OAuth provider
    throw new Error('OAuth validation not implemented');
  }

  /**
   * Validate OIDC token
   * @private
   */
  async validateOIDCToken(data) {
    // OIDC validation implementation
    // This would integrate with OIDC provider
    throw new Error('OIDC validation not implemented');
  }

  /**
   * Validate LDAP credentials
   * @private
   */
  async validateLDAPCredentials(data) {
    // LDAP validation implementation
    // This would integrate with LDAP server
    throw new Error('LDAP validation not implemented');
  }
}

export default EnterpriseAuthManager;
export { EnterpriseAuthManager };</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ABTestingManager.html">ABTestingManager</a></li><li><a href="AuditLogger.html">AuditLogger</a></li><li><a href="AuthMiddleware.html">AuthMiddleware</a></li><li><a href="BPETokenizer.html">BPETokenizer</a></li><li><a href="BaseEngine.html">BaseEngine</a></li><li><a href="BaseLoader.html">BaseLoader</a></li><li><a href="BinaryLoader.html">BinaryLoader</a></li><li><a href="BinaryModel.html">BinaryModel</a></li><li><a href="BitNetLoader.html">BitNetLoader</a></li><li><a href="ConversionConfig.html">ConversionConfig</a></li><li><a href="ConversionResult.html">ConversionResult</a></li><li><a href="EnterpriseAuthManager.html">EnterpriseAuthManager</a></li><li><a href="EnterpriseManager.html">EnterpriseManager</a></li><li><a href="EnterpriseRouter.html">EnterpriseRouter</a></li><li><a href="FormatConverter.html">FormatConverter</a></li><li><a href="GGUFLoader.html">GGUFLoader</a></li><li><a href="GGUFModel.html">GGUFModel</a></li><li><a href="GRPCClient.html">GRPCClient</a></li><li><a href="LLMRouter.html">LLMRouter</a></li><li><a href="MockLoader.html">MockLoader</a></li><li><a href="MockModel.html">MockModel</a></li><li><a href="ModelInterface.html">ModelInterface</a></li><li><a href="ModelQuantizer.html">ModelQuantizer</a></li><li><a href="ModelTemplates.html">ModelTemplates</a></li><li><a href="MultiTenancyManager.html">MultiTenancyManager</a></li><li><a href="PyTorchLoader.html">PyTorchLoader</a></li><li><a href="PyTorchModel.html">PyTorchModel</a></li><li><a href="QuantizationConfig.html">QuantizationConfig</a></li><li><a href="QuantizationResult.html">QuantizationResult</a></li><li><a href="Router.html">Router</a></li><li><a href="SLAMonitor.html">SLAMonitor</a></li><li><a href="SentencePieceTokenizer.html">SentencePieceTokenizer</a></li><li><a href="SimpleLoader.html">SimpleLoader</a></li><li><a href="SimpleModel.html">SimpleModel</a></li><li><a href="TokenizationResult.html">TokenizationResult</a></li><li><a href="TokenizerConfig.html">TokenizerConfig</a></li><li><a href="UniversalTokenizer.html">UniversalTokenizer</a></li><li><a href="ValidationConfig.html">ValidationConfig</a></li><li><a href="ValidationSuite.html">ValidationSuite</a></li><li><a href="ValidationSuiteResult.html">ValidationSuiteResult</a></li><li><a href="ValidationTestResult.html">ValidationTestResult</a></li><li><a href="WordPieceTokenizer.html">WordPieceTokenizer</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Architectures">Architectures</a></li><li><a href="global.html#AuditEventTypes">AuditEventTypes</a></li><li><a href="global.html#AuthMethods">AuthMethods</a></li><li><a href="global.html#BreachSeverity">BreachSeverity</a></li><li><a href="global.html#Capabilities">Capabilities</a></li><li><a href="global.html#ComplianceFrameworks">ComplianceFrameworks</a></li><li><a href="global.html#EnterpriseFeatures">EnterpriseFeatures</a></li><li><a href="global.html#ExperimentStatus">ExperimentStatus</a></li><li><a href="global.html#IsolationLevels">IsolationLevels</a></li><li><a href="global.html#ModelFormat">ModelFormat</a></li><li><a href="global.html#ModelFormats">ModelFormats</a></li><li><a href="global.html#Permissions">Permissions</a></li><li><a href="global.html#QuantizationMethod">QuantizationMethod</a></li><li><a href="global.html#QuantizationPrecision">QuantizationPrecision</a></li><li><a href="global.html#QuotaTypes">QuotaTypes</a></li><li><a href="global.html#RiskLevels">RiskLevels</a></li><li><a href="global.html#RoutingStrategies">RoutingStrategies</a></li><li><a href="global.html#SLAMetricTypes">SLAMetricTypes</a></li><li><a href="global.html#SLAStatus">SLAStatus</a></li><li><a href="global.html#SessionTypes">SessionTypes</a></li><li><a href="global.html#SplittingAlgorithms">SplittingAlgorithms</a></li><li><a href="global.html#StatisticalTests">StatisticalTests</a></li><li><a href="global.html#TimeWindows">TimeWindows</a></li><li><a href="global.html#TokenizerType">TokenizerType</a></li><li><a href="global.html#UserRoles">UserRoles</a></li><li><a href="global.html#ValidationSeverity">ValidationSeverity</a></li><li><a href="global.html#ValidationTestType">ValidationTestType</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#createEnterpriseExpressRoutes">createEnterpriseExpressRoutes</a></li><li><a href="global.html#createEnterpriseRouter">createEnterpriseRouter</a></li><li><a href="global.html#createEnterpriseWebSocketHandlers">createEnterpriseWebSocketHandlers</a></li><li><a href="global.html#defaultEnterpriseConfig">defaultEnterpriseConfig</a></li><li><a href="global.html#enterpriseVersion">enterpriseVersion</a></li><li><a href="global.html#errorMonitoringMiddleware">errorMonitoringMiddleware</a></li><li><a href="global.html#getEnabledFeatures">getEnabledFeatures</a></li><li><a href="global.html#getMonitoringStatus">getMonitoringStatus</a></li><li><a href="global.html#httpMonitoringMiddleware">httpMonitoringMiddleware</a></li><li><a href="global.html#isFeatureEnabled">isFeatureEnabled</a></li><li><a href="global.html#recordCustomMetric">recordCustomMetric</a></li><li><a href="global.html#registerAlertRule">registerAlertRule</a></li><li><a href="global.html#registerDependency">registerDependency</a></li><li><a href="global.html#registerHealthCheck">registerHealthCheck</a></li><li><a href="global.html#setupMonitoring">setupMonitoring</a></li><li><a href="global.html#startPerformanceProfile">startPerformanceProfile</a></li><li><a href="global.html#validateEnterpriseConfig">validateEnterpriseConfig</a></li><li><a href="global.html#withCacheMonitoring">withCacheMonitoring</a></li><li><a href="global.html#withDatabaseMonitoring">withDatabaseMonitoring</a></li><li><a href="global.html#withModelMonitoring">withModelMonitoring</a></li><li><a href="global.html#withQueueMonitoring">withQueueMonitoring</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sun Aug 17 2025 22:28:58 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
